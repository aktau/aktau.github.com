<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>Pipelines in Golang</title>

        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <meta name="description" content="Presents several ways to create a processing pipeline in Go">
        <meta name="keywords" content="pipeline, golang">
        <meta name="author" content="Nicolas Hillegeer">
        <meta name="generator" content="nanoc 4.12.19">
        <meta name="robots" content="index,follow">

        <meta property="og:title" content="Pipelines in Golang">
        <meta property="og:site_name" content="Nicolas Hillegeer - Portfolio and personal blog">
        <meta property="og:type" content="blog">
        <meta property="og:url" content="http://www.aktau.be/draft/2014/07/13/pipelines-in-golang/">

        <!-- Google Fonts embed code -->
        <script>
            (function() {
                var link_element = document.createElement("link"),
                    s = document.getElementsByTagName("script")[0];
                if (window.location.protocol !== "http:" && window.location.protocol !== "https:") {
                    link_element.href = "http:";
                }
                link_element.href += "//fonts.googleapis.com/css?family=EB+Garamond:400";
                link_element.rel = "stylesheet";
                link_element.type = "text/css";
                s.parentNode.insertBefore(link_element, s);
            })();
        </script>
        <noscript>
            <!-- don't leave noscript users out in the cold -->
            <link href='http://fonts.googleapis.com/css?family=EB+Garamond:400' rel='stylesheet' type='text/css'>
        </noscript>

        
        <link rel="stylesheet" type="text/css" href="/stylesheets/all.css">
        

        <link rel="alternate" type="application/atom+xml" title="Posts" href="/atom.xml" />

        <!--[if lt IE 9]><script src="/js/html5shiv.js"></script><![endif]-->
    </head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BPQY780BNR"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      // Old universal analytics ID: ga('create', 'UA-37726728-1', 'aktau.be');
      gtag('config', 'G-BPQY780BNR');
    </script>
    <body>
        <nav>
            <h2>Nicolas Hillegeer</h2>
            <ul>
                <li><a href="/">Blog</a></li>
                <li><a href="/archive/">Archive</a></li>
                <li><a href="/cv-alt/cv.pdf" title="Résumé">Curriculum Vitae</a></li>
                <li><a href="/contact/" title="Personal information">About &amp; Contact</a></li>
            </ul>
            <h2>Online presence</h2>
            <ul>
                <li><a href="https://github.com/Aktau/">Github</a></li>
                <li><a href="https://twitter.com/alazyleopard">Twitter</a></li>
                <li><a href="http://stackoverflow.com/users/558819/aktau">Stack Overflow</a></li>
                <li><a href="https://soundcloud.com/aktau">Soundcloud</a></li>
            </ul>
            <!--
            <h2>Tags</h2>
            <ul>
                
                <li><a href="/tag/introduction">introduction (1)</a></li>
                
                <li><a href="/tag/nanoc">nanoc (1)</a></li>
                
                <li><a href="/tag/pygments">pygments (1)</a></li>
                
                <li><a href="/tag/github">github (2)</a></li>
                
                <li><a href="/tag/unix">unix (1)</a></li>
                
                <li><a href="/tag/c">c (1)</a></li>
                
                <li><a href="/tag/make">make (1)</a></li>
                
                <li><a href="/tag/linux">linux (1)</a></li>
                
                <li><a href="/tag/osx">osx (2)</a></li>
                
                <li><a href="/tag/sdl">sdl (1)</a></li>
                
                <li><a href="/tag/game-engine">game-engine (1)</a></li>
                
                <li><a href="/tag/open-source">open-source (1)</a></li>
                
                <li><a href="/tag/ffmpeg">ffmpeg (1)</a></li>
                
                <li><a href="/tag/github-release">github-release (1)</a></li>
                
                <li><a href="/tag/gofinance">gofinance (1)</a></li>
                
                <li><a href="/tag/golang">golang (1)</a></li>
                
                <li><a href="/tag/cross-compiling">cross-compiling (1)</a></li>
                
                <li><a href="/tag/imessage">imessage (1)</a></li>
                
                <li><a href="/tag/applescript">applescript (1)</a></li>
                
                <li><a href="/tag/postgres">postgres (1)</a></li>
                
                <li><a href="/tag/pigz">pigz (1)</a></li>
                
                <li><a href="/tag/rsync">rsync (1)</a></li>
                
                <li><a href="/tag/sysadmin">sysadmin (1)</a></li>
                
                <li><a href="/tag/neovim">neovim (1)</a></li>
                
                <li><a href="/tag/vim">vim (1)</a></li>
                
                <li><a href="/tag/encoding">encoding (1)</a></li>
                
            </ul>
            -->
        </nav>

        <main id="content">
            
    <div class="post">
        <h1>Pipelines in Golang</h1>
        <aside>July 13, 2014</aside>

        <article>
            <p>Ever wanted to push a bunch of values through a pipeline, to be worked
on by different functions (stages), in parallel or sequentially? In Go
there are a few ways to accomplish that. This article summarizes and
constrasts a few known approaches.</p>

<!-- more -->

<p>To be clear, this article isn’t about emulating <a href="http://labix.org/pipe">Unix shell pipelines in
Go</a>. I consider the package that link points to
as the go-to solution if you want to build a Unix pipeline in Go.</p>

<h2 id="whats-in-a-pipeline">What’s in a pipeline?</h2>

<p>Why would you need a pipeline? If you want to work on a value and pass
it from stage to stage, what could be simpler than:</p>

<pre><code class="language-go"><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="s">"my-value"</span><span class="p">)</span><span class="w">  </span><span class="c1">// could be anything, really</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"The result is:"</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">val1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage1</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
<span class="w">  </span><span class="nx">val2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage2</span><span class="p">(</span><span class="nx">val1</span><span class="p">)</span>
<span class="w">  </span><span class="nx">val3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage3</span><span class="p">(</span><span class="nx">val2</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">val3</span>
<span class="p">}</span>

<span class="c1">// dummy functions</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">stage1</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" -&gt; stage 1"</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">stage2</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" -&gt; stage 2"</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">stage3</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" -&gt; stage 3"</span>
<span class="p">}</span></code></pre>

<p>There’s, that’s just regular, imperative programming. It’s simple, it’s
easy, it’s great. There’s no error handling, I left it out to keep
things short, but you should definitely do that. Now, what if you want to
run things in parallel? A first thought might be to do something like
this:</p>

<pre><code class="language-go"><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// input and output channels for the pipeline</span>
<span class="w">  </span><span class="nx">input</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span>
<span class="w">  </span><span class="nx">output</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="p">)</span><span class="w">  </span><span class="c1">// run start() as a goroutine</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">"my-value"</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"The result is:"</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">output</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// close the input channel so start() will exit and can clean up after</span>
<span class="w">  </span><span class="c1">// itself if it so wishes.</span>
<span class="w">  </span><span class="nb">close</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// will loop until input is closed</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">val1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage1</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="w">    </span><span class="nx">val2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage2</span><span class="p">(</span><span class="nx">val1</span><span class="p">)</span>
<span class="w">    </span><span class="nx">val3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage3</span><span class="p">(</span><span class="nx">val2</span><span class="p">)</span>
<span class="w">    </span><span class="nx">output</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">val3</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Whew, now we’re using goroutines and channels, two of the things Go is
known for. Yet we have not gained any efficiency. We’ve merely increased
the complexity of the solution. There’s two big reasons for that:</p>

<ol>
  <li>We’ve moved all calculations from one goroutine (the main goroutine)
to just one other goroutine: <code>start()</code>. This can’t possibly make
things any faster. <strong>Possible solution</strong>: start more goroutines.</li>
  <li>We immediately demand output after supplying input. This allows only
one value to be in-flight. Yet we can’t split up the loop into an input
loop and an output loop. It would deadlock! The <code>start()</code> goroutine
would be blocked on the <code>output &lt;- val3</code> channel send after the first
iteration of the input loop. Thus, even if we applied the solution to
problem #1, everything would still be sequential. <strong>Possible solution</strong>:
use buffered channels to allow more values to be in-flight.</li>
</ol>

<p>Let’s apply the proposed solutions and see what we get:</p>

<pre><code class="language-go"><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// input and output channels for the pipeline</span>
<span class="w">  </span><span class="nx">nvals</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="nx">input</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">nvals</span><span class="p">)</span>
<span class="w">  </span><span class="nx">output</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">nvals</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">nvals</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">nvals</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">"my-value"</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nb">close</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">nvals</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"The result is:"</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">output</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// will loop until input is closed</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">val1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage1</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="w">    </span><span class="nx">val2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage2</span><span class="p">(</span><span class="nx">val1</span><span class="p">)</span>
<span class="w">    </span><span class="nx">val3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage3</span><span class="p">(</span><span class="nx">val2</span><span class="p">)</span>
<span class="w">    </span><span class="nx">output</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">val3</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Now we’re calculating in parallel. However, though we can decrease the
number of goroutines, we’re still required to construct channels as
large as the number of values we’re going to pass in. And if we decrease
the channel buffers, we need more goroutines to “buffer up” more values
(which is even worse). So we either have O(N) goroutines or channels
with an O(N)-buffer. That’s no good. Perhaps by using another go
construct, we can do better. Enter <code>select</code>:</p>

<pre><code class="language-go"><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// input and output channels for the pipeline</span>
<span class="w">  </span><span class="nx">nvals</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="nx">input</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span>
<span class="w">  </span><span class="nx">output</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">nvals</span><span class="p">;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">"my-value"</span><span class="p">:</span>
<span class="w">      </span><span class="c1">// succesfully input value</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">res</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">output</span><span class="p">:</span>
<span class="w">      </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"The result is:"</span><span class="p">,</span><span class="w"> </span><span class="nx">res</span><span class="p">)</span>
<span class="w">      </span><span class="nx">i</span><span class="o">++</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nb">close</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// will loop until input is closed</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">val1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage1</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="w">    </span><span class="nx">val2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage2</span><span class="p">(</span><span class="nx">val1</span><span class="p">)</span>
<span class="w">    </span><span class="nx">val3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stage3</span><span class="p">(</span><span class="nx">val2</span><span class="p">)</span>
<span class="w">    </span><span class="nx">output</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">val3</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span></code></pre>

<p>We can vary the number of goroutines and the buffers independently (and
measure how we get the best performance). By combining this with
<code>runtime.GOMAXPROCS(runtime.NumCPU())</code>, all cores can be used:</p>

<pre><code class="language-go"><span class="nx">cpus</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">runtime</span><span class="p">.</span><span class="nx">NumCPU</span><span class="p">()</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nx">GOMAXPROCS</span><span class="p">(</span><span class="nx">cpus</span><span class="p">)</span>
<span class="c1">// start as much workers as we have cpus</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">cpus</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">start</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>Yet, we haven’t really been focusing on the pipeline at all. What we’ve
created is just a primitive <a href="https://groups.google.com/forum/#!msg/golang-nuts/o84ISlVWG9g/aXaIW3V8yTAJ">worker
pool</a>.
If a bit more queueing logic is added, a perfectly fine and usable
worker queue comes out.</p>

<blockquote>
  <p>The concept of worker queues is probably well-known among those who
follow how big web companies are performing their heavy processing
tasks. Projects like <a href="https://github.com/resque/resque">resque</a> and
<a href="http://www.celeryproject.org/">celery</a> provide a means to abstract a
worker queue from the programming language used. Sometimes they do this
by using a database/message broker like <a href="http://redis.io/">redis</a> and
consorts as intermediaries.</p>
</blockquote>

<p>I’ve found it helpful to imagine a pipeline as a sequence of worker
pools passing values to each other. Each worker pool is called a
<strong>stage</strong>. It’s possible for a worker pool to have just one worker, in
which case that stage would run in sequence and won’t need
synchronization.</p>

<p>To turn our earlier example into a true pipeline, we need to break out
the stages and let them run in their own worker pool:</p>

<pre><code class="language-go"><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// input and output channels for the pipeline</span>
<span class="w">  </span><span class="nx">nvals</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">10</span>

<span class="w">  </span><span class="nx">ncpu</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">runtime</span><span class="p">.</span><span class="nx">NumCPU</span><span class="p">()</span>
<span class="w">  </span><span class="nx">runtime</span><span class="p">.</span><span class="nx">GOMAXPROCS</span><span class="p">(</span><span class="nx">ncpu</span><span class="p">)</span>

<span class="w">  </span><span class="nx">stages</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kd">func</span><span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">string</span><span class="p">){</span>
<span class="w">    </span><span class="nx">stage1</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stage2</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">input</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span>
<span class="w">  </span><span class="nx">in</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">input</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">stage</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">stages</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">out</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">stage</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span><span class="w"> </span><span class="nx">out</span><span class="p">)</span><span class="w">  </span><span class="c1">// run start() as a goroutine</span>
<span class="w">    </span><span class="nx">in</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">out</span><span class="w">  </span><span class="c1">// the output of one stage is the input of the next one</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">output</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">in</span><span class="w"> </span><span class="c1">// the output of the last stage</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">nvals</span><span class="p">;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">"my-value"</span><span class="p">:</span>
<span class="w">      </span><span class="c1">// succesfully input value</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">res</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">output</span><span class="p">:</span>
<span class="w">      </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"The result is:"</span><span class="p">,</span><span class="w"> </span><span class="nx">res</span><span class="p">)</span>
<span class="w">      </span><span class="nx">i</span><span class="o">++</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nb">close</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">stage1</span><span class="p">(</span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// propagate the closing of the input channel</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nb">close</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">output</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">stage1fn</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">stage2</span><span class="p">(</span><span class="nx">input</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// propagate the closing of the input channel</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nb">close</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">output</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">stage2fn</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">stage1fn</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" -&gt; stage 1"</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">stage2fn</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" -&gt; stage 2"</span>
<span class="p">}</span></code></pre>

<p>Very groovy. But the astute reader will notice that we’ve regressed
quite a bit: we only start as many goroutines as we have stages and all
stages naturally run in sequence. This means that the performance will
be on par with the very first example, which was just a sequence of
plain function calls. In fact, performance will be worse, as we get
goroutine creation and channel sync overhead. It’s also unclear what
advantages, if any, this approach has over regular function calls. It
just seems more complex.</p>

<p>Perhaps it’s time to stop dabbling around and provide some powerful
helper functions that will let us compose pipelines that use</p>

<p>TODO: Wide/Batch/Single/…</p>

<p>Now we can also see what advantages this might pose over just starting
<code>#cpus</code> workers and letting each of them run all the stages until the
input is exhausted, as was proposed near the beginning of the article:</p>

<ul>
  <li>More granular control over parallelism</li>
  <li>Work stealing (contrast web vs parallel lines approach, graphic?).
This can equal more efficient system resource utilization. Imagine
that stage #1 is reponsible for reading files from storage, and stage
#2 for processing them (like computing MD5’s). In the single worker
pool approach, when a worker is busy calculating an MD5, it’s not busy
reading a file. Yet these are usually things that can be done in
parallel, the kernel issues a DMA request to wherever the request
contents are and the requesting thread can go do something else (this
approach is enshrined in the <code>epoll/kqueue/...</code> APIs). When using
pipelines, utilization is higher, because all workers for stage 2 can
be busy calculating MD5’s and all workers for stage 1 can have a
storage request underway. That way there’s less downtime and thus
lower latency at little extra CPU cost.</li>
</ul>

<p>This also indicates that it’s a good idea to split up IO tasks from
CPU-heavy tasks and put them in separate stages. On the flipside,
splitting a CPU-heavy task into multiple stages might not yield any
gains at all (it might actually decrease performance because of cache
efficiency losses).</p>

<p>Yet when we know we’re working with Go, we can simplify and generalize
this concept. Enter the pipeline.</p>

<p>Queues have a nice analogue in Go: channels. They provide some of the
semantics we are looking for:</p>

<ul>
  <li>Safe to use from multiple goroutines</li>
  <li>First-in First-out (FIFO)</li>
</ul>

<p>There’s one little catch: channels are bounded by their capacity. This
is true for any queue. This can be a good thing: sending into a full
channel will block until there is room, so it’s a natural backpressure
mechanism. Clever ways can be thought of to deal with this backpressure,
such as throwing away the work, or starting up another pipeline.
However, to truly emulate queue’s such as those represented by redis’
LISTs better, one could prepend a pipeline stage that uses an <a href="https://github.com/eapache/channels">infinite
channel</a> to buffer up all input.
Making it seem to the caller that there is no backpressure. The caveat
being that it’s possible for the system to run out of memory and thus
make the program fail. It’s possible to build safeguards for this but
they’re not as “convenient” as checking for <code>NULL</code> from <code>malloc()</code>.</p>

<p>Why would one want to use a pipeline instead of just straight-line code
or starting a goroutine for every item you want to process in parallel
(and then waiting on a
<a href="http://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a> or extracting N
values from a channel)?</p>

<ol>
  <li>Bounded parallelism: avoid spawning 1000’s of goroutines when it’s
not necessary (you most likely don’t have 1000’s of processors).
Goroutines are cheap, but they’re not that cheap. <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>
</li>
  <li>Some pipelines support cancellation, freeing you from building it
yourself in an ad-hoc way everytime.</li>
  <li>You can pass some pipelines around. This allows inputting values into
an already running pipeline without worrying. This makes sure the end
results are sequenced correctly in time (after other calls), yet they
don’t have to block until the work is done.</li>
  <li>Batching: (combine results into big INSERT statements), difficult to
do with many parallel pipelines (worker pools) as in the beginning of
the article.</li>
</ol>

<p>Some links describing possible instances of pipeline:</p>

<ol>
  <li><a href="http://blog.golang.org/pipelines">Go blog: pipelines</a></li>
  <li><a href="https://groups.google.com/forum/#!topic/golang-nuts/cHvGb_wOExw">Dimitri Vyukov’s pipeline</a></li>
</ol>

<h2 id="use-cases">Use cases</h2>

<h2 id="streaming-pipeline">Streaming pipeline</h2>

<p>TCP sockets can be seen as an instance of a streaming pipeline.</p>

<h2 id="value-pipeline">Value pipeline</h2>

<p>Inside of the boundaries of a programming language, it’s often easiest
to think of a pipeline as a bunch of values to be passed through a few
stages and spit out at the end. Contrast this with a stream of values
where one has to make an effort to discern the logical pieces
(messages).</p>

<p>When working with one language, this is jut not necessary. We already
have a perfectly fine way to delimit a message: types. To make things
generic, it seems like we’d have to pass <code>interface{}</code> values.</p>

<h2 id="ad-hoc-pipeline">Ad-hoc pipeline</h2>

<p>Go blog approach.</p>

<h2 id="function-pipeline">Function pipeline</h2>

<p>Dimitri’s approach.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">

      <p>At the moment of speaking (Go 1.3), creating a goroutine costs around 5000
bytes. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

        </article>

        <p>Tags: <a href="/tag/pipeline" rel="tag">pipeline</a>, <a href="/tag/golang" rel="tag">golang</a></p>
    </div>

        </main>

        <!-- mathjax config similar to math.stackexchange -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
              jax: ["input/TeX", "output/HTML-CSS"],
              tex2jax: {
                inlineMath: [ ['$', '$'], ["\\(", "\\)"] ],
                displayMath: [ ['$$', '$$'], ["\\[", "\\]"] ],
                processEscapes: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
              },
              "HTML-CSS": { scale: 180 },
              //displayAlign: "left",
              //displayIndent: "2em"
            });
        </script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
        <script src="/js/pjax-standalone.js"></script>
        <script>
            pjax.connect({
                "container": "content",
                "complete": function() {
                    // reload mathjax after a pjax load
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
                },
                "autoAnalytics": false
            });
        </script>
    </body>
</html>

