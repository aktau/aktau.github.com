<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>A makefile for modern C programming on UNIX-like operating systems</title>

        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <meta name="description" content="Presents a (hopefully) understandable makefile that can be used for cross-platform, cross-compiler projects in C/C++">
        <meta name="keywords" content="unix, c, make, linux, osx">
        <meta name="author" content="Nicolas Hillegeer">
        <meta name="generator" content="nanoc 4.12.19">
        <meta name="robots" content="index,follow">

        <meta property="og:title" content="A makefile for modern C programming on UNIX-like operating systems">
        <meta property="og:site_name" content="Nicolas Hillegeer - Portfolio and personal blog">
        <meta property="og:type" content="blog">
        <meta property="og:url" content="http://www.aktau.be/2013/08/07/a-makefile-for-modern-c-programming-on-unix-like-operating-systems/">

        <!-- Google Fonts embed code -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400&display=swap" rel="stylesheet">

        
        <link rel="stylesheet" type="text/css" href="/stylesheets/all.css">
        

        <link rel="alternate" type="application/atom+xml" title="Posts" href="/atom.xml" />

        <!--[if lt IE 9]><script src="/js/html5shiv.js"></script><![endif]-->
    </head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BPQY780BNR"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      // Old universal analytics ID: ga('create', 'UA-37726728-1', 'aktau.be');
      gtag('config', 'G-BPQY780BNR');
    </script>
    <body>
        <nav>
            <h2>Nicolas Hillegeer</h2>
            <ul>
                <li><a href="/">Blog</a></li>
                <li><a href="/archive/">Archive</a></li>
                <li><a href="/cv-alt/cv.pdf" title="Résumé">Curriculum Vitae</a></li>
                <li><a href="/contact/" title="Personal information">About &amp; Contact</a></li>
            </ul>
            <h2>Online presence</h2>
            <ul>
                <li><a href="https://github.com/Aktau/">Github</a></li>
                <li><a href="https://twitter.com/alazyleopard">Twitter</a></li>
                <li><a href="http://stackoverflow.com/users/558819/aktau">Stack Overflow</a></li>
                <li><a href="https://soundcloud.com/aktau">Soundcloud</a></li>
            </ul>
            <!--
            <h2>Tags</h2>
            <ul>
                
                <li><a href="/tag/introduction">introduction (1)</a></li>
                
                <li><a href="/tag/nanoc">nanoc (1)</a></li>
                
                <li><a href="/tag/pygments">pygments (1)</a></li>
                
                <li><a href="/tag/github">github (2)</a></li>
                
                <li><a href="/tag/unix">unix (1)</a></li>
                
                <li><a href="/tag/c">c (1)</a></li>
                
                <li><a href="/tag/make">make (1)</a></li>
                
                <li><a href="/tag/linux">linux (1)</a></li>
                
                <li><a href="/tag/osx">osx (2)</a></li>
                
                <li><a href="/tag/sdl">sdl (1)</a></li>
                
                <li><a href="/tag/game-engine">game-engine (1)</a></li>
                
                <li><a href="/tag/open-source">open-source (1)</a></li>
                
                <li><a href="/tag/ffmpeg">ffmpeg (1)</a></li>
                
                <li><a href="/tag/github-release">github-release (1)</a></li>
                
                <li><a href="/tag/gofinance">gofinance (1)</a></li>
                
                <li><a href="/tag/golang">golang (1)</a></li>
                
                <li><a href="/tag/cross-compiling">cross-compiling (1)</a></li>
                
                <li><a href="/tag/imessage">imessage (1)</a></li>
                
                <li><a href="/tag/applescript">applescript (1)</a></li>
                
                <li><a href="/tag/postgres">postgres (1)</a></li>
                
                <li><a href="/tag/pigz">pigz (1)</a></li>
                
                <li><a href="/tag/rsync">rsync (1)</a></li>
                
                <li><a href="/tag/sysadmin">sysadmin (1)</a></li>
                
                <li><a href="/tag/neovim">neovim (1)</a></li>
                
                <li><a href="/tag/vim">vim (1)</a></li>
                
                <li><a href="/tag/encoding">encoding (1)</a></li>
                
            </ul>
            -->
        </nav>

        <main id="content">
            
    <div class="post">
        <h1>A makefile for modern C programming on UNIX-like operating systems</h1>
        <aside>August 7, 2013</aside>

        <article>
            <p>Looking for an easy to use build tool? Project not yet large enough to
warrant cmake? Downright scared of autotools (which generates the
scariest kind of makefiles)? May I present… make!</p>

<!-- more -->

<p>Most of you have probably seen what a makefile looks like, either from
another open source project or automatically generated by tools like
<a href="http://orwelldevcpp.blogspot.de/">Dev-C++</a> <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> or (god forbid)
autotools. They usually have one thing in common: <strong>they’re horrendous,
unreadable messes</strong>. And it makes you never want to touch make with a
10-foot pole.</p>

<p>It was just recently that I learned that it didn’t have to be that way,
make can be small and simple. Let’s start with the simplest of
makefiles, which compiles a single .c file into an application. Save the
following into a file with the name Makefile, next to a main.c file.
<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">c</span>
<span class="w">    </span>gcc<span class="w"> </span>-o<span class="w"> </span>myapp<span class="w"> </span>main.c<span class="w"> </span>-I.</code></pre>

<p>To run it, execute:</p>

<pre><code class="language-bash">$<span class="w"> </span>make<span class="w"> </span>myapp
<span class="c1"># or... absent a specific target, make will</span>
<span class="c1"># just execute the first one it finds.</span>
$<span class="w"> </span>make</code></pre>

<p>(if you get strange errors when you try this, it’s because you haven’t
been indenting your lines with a TAB-character. Make explicitly requires
that lines be indented with tabs or it will throw a hissy fit and spout
poorly worded error messages from which it is impossible to infer that
it actually wants tabs.)</p>

<p>So, what does this do? Make will try to create the target (<strong>myapp</strong>) by
checking if the dependencies (<strong>main.c</strong>) exist or have been modified
more recently than an already existing <strong>myapp</strong>. The way to produce the
target from the dependencies is specified by the rule, in this case the
<strong>gcc</strong> invocation. IF <strong>myapp</strong> already exists and is more recent than
<strong>main.c</strong>, nothing happens:</p>

<pre><code class="language-bash">$<span class="w"> </span>make
gcc<span class="w"> </span>-o<span class="w"> </span>myapp<span class="w"> </span>main.c<span class="w"> </span>-I.

$<span class="w"> </span>make
make:<span class="w"> </span>Nothing<span class="w"> </span>to<span class="w"> </span>be<span class="w"> </span><span class="k">done</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="sb">`</span>all<span class="err">'</span>.

$<span class="w"> </span>edit<span class="w"> </span>main.c
$<span class="w"> </span>make
gcc<span class="w"> </span>-o<span class="w"> </span>myapp<span class="w"> </span>main.c<span class="w"> </span>-I.

$<span class="w"> </span>rm<span class="w"> </span>myapp<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make
gcc<span class="w"> </span>-o<span class="w"> </span>myapp<span class="w"> </span>main.c<span class="w"> </span>-I.</code></pre>

<p>If one of the dependencies is missing and make doesn’t know how to make
it (with another rule), make will error out.  Likewise if one of the
steps produces an error, make will stop (unless specifically told to
ignore the error).</p>

<p>Put more abstractly, make is just trying to produce output, which look
like this:</p>

<pre><code class="language-make"><span class="nf">&lt;output&gt;</span><span class="o">:</span><span class="w"> </span>&lt;<span class="n">dependencies</span>&gt;
<span class="w">    </span>&lt;steps<span class="w"> </span>to<span class="w"> </span>make<span class="w"> </span>output<span class="w"> </span>from<span class="w"> </span>dependencies&gt;</code></pre>

<p>So, in these terms, make’s reasoning becomes clearer: to get <em>output</em>
<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>, I need <em>dependencies</em> and then I need to run <em>steps to make
output from dependencies</em>. If the dependencies are lacking, make will
try to make them if it has a rule for them. Please note that the part
called output is often also called a target.</p>

<p>In the case above, <em>main.c</em> already exists, so it doesn’t need to be made. Lucky for us,
as we didn’t specify a rule to make <em>main.c</em>.</p>

<p>In most C projects, there’s a tendency to first generate the object (.o) files and then
generate the application from them. Doing this presents a nice opportunity to show multiple
rules working in tandem:</p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">o</span>
<span class="w">    </span>gcc<span class="w"> </span>main.o<span class="w"> </span>-o<span class="w"> </span>myapp<span class="w"> </span>-I.

<span class="nf">main.o</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">c</span>
<span class="w">    </span>gcc<span class="w"> </span>-c<span class="w"> </span>main.c<span class="w"> </span>-o<span class="w"> </span>main.o</code></pre>

<p>So now we’re first compiling to object files and then linking them together into
an executable, great! But what if we want to add another file? Suppose we have
another file called helper.c that we want to compile and link into our executable,
we could do this:</p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">o</span> <span class="n">helper</span>.<span class="n">o</span>
<span class="w">    </span>gcc<span class="w"> </span>main.o<span class="w"> </span>helper.o<span class="w"> </span>-o<span class="w"> </span>myapp<span class="w"> </span>-I.

<span class="nf">main.o</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">c</span>
<span class="w">    </span>gcc<span class="w"> </span>-c<span class="w"> </span>main.c<span class="w"> </span>-o<span class="w"> </span>main.o

<span class="nf">helper.o</span><span class="o">:</span><span class="w"> </span><span class="n">helper</span>.<span class="n">c</span>
<span class="w">    </span>gcc<span class="w"> </span>-c<span class="w"> </span>helper.c<span class="w"> </span>-o<span class="w"> </span>helper.o</code></pre>

<p>Note that we added helper.o as a new dependency for myapp, and that we specified
a rule for how to build helper.o from helper.c.</p>

<p>This works perfectly fine, but it’s getting kind of repetitive. Is there no way we
can fold the two last rules into one? Basically the only thing that differs
between them is the filename.</p>

<p>Sure, but that’s usually where it gets hairy for someone not accustomed to make.
Make has some special variables you can use inside of a rules to get rid of
the redundancy, but they’re very (very) poorly named.
The following four are pretty important, for starters:</p>

<ul>
  <li>
<strong>$@</strong>: the name of the target file (the one before the colon)</li>
  <li>
<strong>$&lt;</strong>: the name of the first (or only) dependency (the first one after the colon)</li>
  <li>
<strong>$^</strong>: the names of all the dependencies (space separated)</li>
  <li>
<strong>$</strong>*: the stem (the bit which matches the % wildcard in a rule definition. (I’m not using this now, but it could be handy someday)</li>
</ul>

<p>These special variables, combined with wildcards (the <strong>%</strong> symbol in make), allow us
to compactly eliminate all the redundancy. An example will probably clarify it
better than a thousand words.</p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">o</span> <span class="n">helper</span>.<span class="n">o</span>
<span class="w">    </span>gcc<span class="w"> </span>$^<span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span>

<span class="c"># when looking for something that ends in .o, look</span>
<span class="c"># for the same thing ending in .c and run gcc on it</span>
<span class="nf">%.o</span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span>
<span class="w">    </span>gcc<span class="w"> </span>-c<span class="w"> </span>$&lt;</code></pre>

<p>There, redundancy solved! We only had to specify the name of the executable, and the object files
that are necessary to build the executable exactly once. If you expand
the variables in your head, it also looks quite logical.</p>

<p>Now there are some tiny tweaks that I do quite often to add
some commandline overridability:</p>

<pre><code class="language-make"><span class="c"># if $CC is not set, use gcc as a sensible default</span>
<span class="nv">CC</span><span class="w"> </span><span class="o">?=</span><span class="w"> </span>gcc

<span class="c"># if $CFLAGS is not set, be very pedantic and compile</span>
<span class="c"># as C11, that should catch some common errors, also</span>
<span class="c"># fortify the source, which is a must for security.</span>
<span class="nv">CFLAGS</span><span class="w"> </span><span class="o">?=</span><span class="w"> </span>-Wall<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-D_FORTIFY_SOURCE<span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wextra<span class="w"> </span>-Wcast-align<span class="w"> </span>-Wcast-qual<span class="w"> </span>-Wpointer-arith<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Waggregate-return<span class="w"> </span>-Wunreachable-code<span class="w"> </span>-Wfloat-equal<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wformat<span class="o">=</span><span class="m">2</span><span class="w"> </span>-Wredundant-decls<span class="w"> </span>-Wundef<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wdisabled-optimization<span class="w"> </span>-Wshadow<span class="w"> </span>-Wmissing-braces<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wstrict-aliasing<span class="o">=</span><span class="m">2</span><span class="w"> </span>-Wstrict-overflow<span class="o">=</span><span class="m">5</span><span class="w"> </span>-Wconversion<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wno-unused-parameter<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-pedantic<span class="w"> </span>-std<span class="o">=</span>c11

<span class="nf">myapp</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">o</span> <span class="n">helper</span>.<span class="n">o</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>$^<span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span>

<span class="c"># when looking for something that ends in .o, look</span>
<span class="c"># for the same thing ending in .c and run gcc on it</span>
<span class="nf">%.o</span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span>$&lt;<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span></code></pre>

<p>That cranks the warnings up to 11, which is often
a good thing.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> It’s a good idea to turn the warnings on when
you start your project. Solving the deluge of warnings that
can come out of a mature project when going from no flags
to very pedantic is not fun.</p>

<h3 id="debug-and-release-builds">Debug and release builds</h3>

<p>Quite often, you’d want to compile in debug mode but be
able to run</p>

<pre><code class="language-bash">$<span class="w"> </span>make<span class="w"> </span>release</code></pre>

<p>When you’re done, spitting out a fully optimized and stripped
executable.</p>

<p>In make, there are often quite a few ways to achieve the
same thing, adding to the confusion. For debug and release
builds, I personally went for something really simple, expanding
our last example:</p>

<pre><code class="language-make"><span class="c"># if $CC is not set, use gcc as a sensible default</span>
<span class="nv">CC</span><span class="w"> </span><span class="o">?=</span><span class="w"> </span>gcc

<span class="c"># if $CFLAGS is not set, be very pedantic and compile</span>
<span class="c"># as C11, that should catch some common errors, also</span>
<span class="c"># fortify the source, which is a must for security.</span>
<span class="nv">CFLAGS</span><span class="w"> </span><span class="o">?=</span><span class="w"> </span>-Wall<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-D_FORTIFY_SOURCE<span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wextra<span class="w"> </span>-Wcast-align<span class="w"> </span>-Wcast-qual<span class="w"> </span>-Wpointer-arith<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Waggregate-return<span class="w"> </span>-Wunreachable-code<span class="w"> </span>-Wfloat-equal<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wformat<span class="o">=</span><span class="m">2</span><span class="w"> </span>-Wredundant-decls<span class="w"> </span>-Wundef<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wdisabled-optimization<span class="w"> </span>-Wshadow<span class="w"> </span>-Wmissing-braces<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wstrict-aliasing<span class="o">=</span><span class="m">2</span><span class="w"> </span>-Wstrict-overflow<span class="o">=</span><span class="m">5</span><span class="w"> </span>-Wconversion<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-Wno-unused-parameter<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-pedantic<span class="w"> </span>-std<span class="o">=</span>c11

<span class="nv">CFLAGS_DEBUG</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>-g3<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-O<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-DDEBUG

<span class="nv">CFLAGS_RELEASE</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>-O2<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-march<span class="o">=</span>native<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-mtune<span class="o">=</span>native<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-ftree-vectorize

<span class="c"># the default target is debug</span>
<span class="nf">all</span><span class="o">:</span><span class="w"> </span><span class="n">debug</span>

<span class="c"># when the target is debug,</span>
<span class="c"># add CFLAGS_DEBUG to CFLAGS</span>
<span class="nf">debug</span><span class="o">:</span><span class="w"> </span><span class="n">CFLAGS</span> += <span class="k">$(</span><span class="nv">CFLAGS_DEBUG</span><span class="k">)</span>
<span class="nf">debug</span><span class="o">:</span><span class="w"> </span><span class="n">myapp</span>

<span class="c"># when the target is release,</span>
<span class="c"># add CFLAGS_RELEASE to CFLAGS</span>
<span class="nf">release</span><span class="o">:</span><span class="w"> </span><span class="n">CFLAGS</span> += <span class="k">$(</span><span class="nv">CFLAGS_RELEASE</span><span class="k">)</span>
<span class="nf">release</span><span class="o">:</span><span class="w"> </span><span class="n">myapp</span>

<span class="nf">myapp</span><span class="o">:</span><span class="w"> </span><span class="n">main</span>.<span class="n">o</span> <span class="n">helper</span>.<span class="n">o</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>$^<span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span>

<span class="c"># when looking for something that ends in .o, look</span>
<span class="c"># for the same thing ending in .c and run gcc on it</span>
<span class="nf">%.o</span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span>$&lt;<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span>

<span class="nf">.PHONY</span><span class="o">:</span><span class="w"> </span><span class="n">debug</span> <span class="n">release</span></code></pre>

<p>We’re using <strong>target-specific variables</strong> to get
the job done. Notice that we added release and debug
as phony targets because they don’t generate files
called release and debug. Also note that both
target and debug have myapp as a dependency, so
they will both build the executable we want,
albeit with different flags.</p>

<h3 id="taking-into-account-differences-in-operating-systems-or-compilers">Taking into account differences in operating systems or compilers</h3>

<p>So now you’ve got your fancy project building in debug and release modes
and you’re really happy about it, but what when you’ve been developing
on OSX and want to build &amp; run it on Linux as well? Or what if
you want to support clang because of its awesome diagnostics?</p>

<p>With make, you can run some commands to find out what your environment
looks like and make choices based on that. The long and short of it
can be found on <a href="http://stackoverflow.com/questions/714100/os-detecting-makefile">stack overflow</a>.
I’ll repaste my own edited version here for posterity:</p>

<pre><code class="language-make"><span class="cp">ifeq ($(OS),Windows_NT)</span>
<span class="w">    </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>WIN32
<span class="cp">    ifeq ($(PROCESSOR_ARCHITECTURE),AMD64)</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>AMD64
<span class="cp">    endif</span>
<span class="cp">    ifeq ($(PROCESSOR_ARCHITECTURE),x86)</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>IA32
<span class="cp">    endif</span>
<span class="cp">else</span>
<span class="c">    # tries to find the compiler name</span>
<span class="w">    </span>CC_VERSION<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>--version<span class="w"> </span><span class="p">|</span><span class="w"> </span>head<span class="w"> </span>-1<span class="w"> </span><span class="p">|</span><span class="w"> </span>cut<span class="w"> </span>-f1<span class="w"> </span>-d<span class="s1">' '</span><span class="k">)</span>

<span class="c">    # tries to discern what UNIX-like OS we're running on</span>
<span class="w">    </span>UNAME_S<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span>uname<span class="w"> </span>-s<span class="k">)</span>

<span class="cp">    ifeq ($(UNAME_S),Linux)</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>LINUX
<span class="cp">    endif</span>
<span class="cp">    ifeq ($(UNAME_S),Darwin)</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>OSX
<span class="cp">    endif</span>

<span class="cp">    ifneq (,$(findstring clang,$(CC_VERSION)))</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>CLANG

<span class="c">        # -pthread is not necessary when using Clang on Darwin</span>
<span class="cp">        ifneq ($(UNAME_S),Darwin)</span>
<span class="w">            </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-pthread
<span class="cp">        endif</span>
<span class="cp">    else</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>GCC
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-pthread

<span class="c">        # at least on OS X 10.7.5, the apple linker does</span>
<span class="c">        # not understand AVX and gcc uses it when you specify</span>
<span class="c">        # -mavx or -march=native and you have a CPU</span>
<span class="c">        # with AVX or better</span>
<span class="cp">        ifeq ($(UNAME_S),Darwin)</span>
<span class="w">            </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-mno-avx
<span class="cp">        endif</span>
<span class="cp">    endif</span>

<span class="w">    </span>UNAME_P<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span>uname<span class="w"> </span>-m<span class="k">)</span>

<span class="cp">    ifeq ($(UNAME_P),x86_64)</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>AMD64
<span class="cp">    endif</span>
<span class="cp">    ifneq ($(filter %86,$(UNAME_P)),)</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>IA32
<span class="cp">    endif</span>
<span class="cp">    ifneq ($(filter arm%,$(UNAME_P)),)</span>
<span class="w">        </span><span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-D<span class="w"> </span>ARM
<span class="cp">    endif</span>
<span class="cp">endif</span></code></pre>

<p>It adds define flags so that whenever necessary, it can be used
to partially define blocks of code based on OS, CPU or compiler.
Of course I should note that this is best used when there are no
obvious alternatives, nobody likes <code>#ifdef</code> soup.</p>

<p>By the way, I was bashing autotools earlier for being a mess and
creating unreadable makefiles, but it remains an oft-used toolset for
cross-platform building.  Is it because of inertia? Well… yes and no.
Sometimes building on many (very) different operating systems becomes
quite a chore, and autotools makes some of that, well, easier. It was
built long ago for the express purpose of generating cross-platform
makefiles, which is also why it panders to the lowest common denominator
by not using any of the newer features that modern make has. Which in
turn generates ugly makefiles.</p>

<p>There are <a href="http://cgit.freedesktop.org/libva/">a lot</a> of
<a href="http://cgit.freedesktop.org/xorg/driver/xf86-video-intel/">examples</a> of
<a href="http://www.mplayerhq.hu/design7/news.html">projects</a> using autotools to
great effect, even maintaining almost readable autoconf.ac files.  One
could copy and paste given a bit of effort and after a while you could
be an autotools adept too (not a wizard, I suppose there are only 3
people in the world like that).</p>

<p>A decent alternative is <a href="http://www.cmake.org/">cmake</a>, which tends to
be a bit more readable, and can generate makefiles on UNIX platforms and
visual studio project files on windows, if that’s your thing.</p>

<p>But when your project exhibits just slight differences between OS or
compiler toolchains, there’s no need to take the plunge and migrate to
autotools, cmake or anything else just yet. We can make do with modern
make, and still keep it quite readable.</p>

<p>Oh, and there’s another thing cmake, autotools and its ilk are pretty
good at: finding dependencies such as libraries. This used to be much
more important and difficult to do with make. But thanks to the rise of
<a href="http://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a>, I
find that plain make will do fine for smaller projects. An example from
<a href="https://github.com/aktau/hhpc/blob/master/Makefile">one of my projects</a>
which uses <em>pkg-config</em> to find where the X11 libraries and headers
files are located on the target system:</p>

<pre><code class="language-make"><span class="nf">$(EXECUTABLE)</span><span class="o">:</span><span class="w"> </span><span class="k">$(</span><span class="nv">OBJECTS</span><span class="k">)</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span>pkg-config<span class="w"> </span>--libs<span class="w"> </span>x11<span class="k">)</span><span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span>$^<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span>

<span class="nf">%.o</span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span>pkg-config<span class="w"> </span>--cflags<span class="w"> </span>x11<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span>$&lt;<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span></code></pre>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Sweet nostalgia, Dev-C++ was my first real IDE, it helped me form my knowledge of C by being easy to use yet not having auto-completion, which cemented a lot of important functions in my muscle memory. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Note that I’m describing makefiles for a C project here, but any developer worth her salt should be able to see that it’s applicable to much more. In fact I use make in combination with <a href="https://github.com/jordansissel/fpm">fpm</a> to build .deb files for debian/ubuntu, all I have to do is run <code>make deb</code>. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Some might start protesting now, as they’ve seen “outputs” like <strong>install, uninstall, clean, etc.</strong> that don’t generate files called install, uninstall or clean. The thing is that these targets are special, and they are usually indicated as such by a special target called <strong>.PHONY</strong>. Make doesn’t need or want to know about the files generated by phony rules. Phony rules will always execute when called, multiple invocations to <code>make install</code> will, by default, do the same thing. If you forget to add a target such as <strong>install</strong> to the phony rules, it will still work of course, because your install rules don’t generate a file called install and thus make will keep executing it.  Correctly specifying the phony rules is cleaner though. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Of course, there are some flags that might be a little bit too pedantic. For example, when doing game development it’s often useful to do some <a href="http://graphics.stanford.edu/~seander/bithacks.html">bit twiddling</a>, compare disparate number types and do dirty things with pointers.  In that case it might not be worth it or even possible to prevent all the warnings by casting to the appropriate type. In that case, feel free to disable some flags. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

        </article>

        <p>Tags: <a href="/tag/unix" rel="tag">unix</a>, <a href="/tag/c" rel="tag">c</a>, <a href="/tag/make" rel="tag">make</a>, <a href="/tag/linux" rel="tag">linux</a>, <a href="/tag/osx" rel="tag">osx</a></p>
    </div>

        </main>

        <!-- mathjax config similar to math.stackexchange -->
        <script>
          window.MathJax = {
            tex: {
              inlineMath: [ ['$', '$'], ["\\(", "\\)"] ],
              displayMath: [ ['$$', '$$'], ["\\[", "\\]"] ],
              processEscapes: true,
              autoload: {
                color: [],
                colorv2: ['color']
              },
              packages: {'[+]': ['noerrors']}
            },
            options: {
              skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
              ignoreHtmlClass: 'tex2jax_ignore',
              processHtmlClass: 'tex2jax_process'
            },
            chtml: {
              scale: 1.8
            },
            loader: {
              load: ['[tex]/noerrors']
            }
          };
        </script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>
        <script src="/js/pjax-standalone.js"></script>
        <script>
            pjax.connect({
                "container": "content",
                "complete": function() {
                    // reload mathjax after a pjax load
                    MathJax.typesetPromise();
                },
                "autoAnalytics": false
            });
        </script>
    </body>
</html>

